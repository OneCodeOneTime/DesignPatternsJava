//-------------介绍--------------------------begin
装饰模式又名包装（Wrapper）模式。
装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。
装饰模式通过创建一个包装对象，也就是装饰，来包裹真实的对象。
装饰模式以对客户端透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。
装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展。
装饰模式把客户端的调用委派到被装饰类。装饰模式的关键在于这种扩展是完全透明的。
java的I/O流就是使用装饰者模式设计的。
//-------------介绍--------------------------end



//-------------角色功能--------------------------begin
抽象构件角色（Component）：给出一个抽象接口，以规范准备接收附加责任的对象。

具体构件角色（Concrete Component）：定义将要接收附加责任的类。

装饰角色（Decorator）：持有一个构件（Component）对象的引用，并定义一个与抽象构件接口一致的接口。

具体装饰角色（Concrete Decorator）：负责给构件对象“贴上”附加的责任。
//-------------角色功能--------------------------end


//-------------特点--------------------------begin
        装饰对象和真实对象有相同的接口。这样客户端对象就可以以和真实对象相同的方式和装饰对象交互。
　　装饰对象包含一个真实对象的引用（reference）。
　　装饰对象接收所有来自客户端的请求，它把这些请求转发给真实的对象。
　　装饰对象可以在转发这些请求之前或之后附加一些功能。
　　这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。
//-------------特点--------------------------end

//-------------简要步骤--------------------------begin
继承或者实现 Component 组件，生成一个 Decorator 装饰者抽象类；
在生成的这个 Decorator 装饰者类中，增加一个 Component 的私有成员对象；
将 ConcreteComponent 或者其他需要被装饰的对象传入 Decorator 类中并赋值给上一步的 Component 对象；
在装饰者 Decorator 类中，将所有的操作都替换成该 Component 对象的对应操作；
在 ConcreteDecorator 类中，根据需要对应覆盖需要重写的方法。
//-------------简要步骤--------------------------end