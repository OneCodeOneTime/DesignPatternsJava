//-------------介绍--------------------------begin
策略模式：定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。也称为政策模式(Policy)。
算法族的可相互替代。
策略模式就说明算法不单一，可以应用多种方式，算法之间可以相互替换。
应用场景：
1） 许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。
2） 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的算法。当这些变体实现为一个算法的类层次时 ,可以使用策略模式。
3） 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。
4） 一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。


//-------------介绍--------------------------end



//-------------角色功能--------------------------begin
上下文角色（Context）：可注入一个策略对象，持有一个策略的引用。客户端通过上下文对象来调用策略。

抽象策略角色（Strategy）：定义了一个上下文对象可调用的公共方法。

具体策略角色（Concrete Strategy）：实现抽象策略类的公共方法，并提供不同的可替代的实现。
//-------------角色功能--------------------------end



//-------------简要步骤--------------------------begin
定义一个抽象策略类，定义所有具体策略类需要实现的公共方法。也是具体算法的入口。
定义一组具体策略类，各自为抽象类的公共方法提供不同的可替代的实现。
定义上下文对象，内含可注入策略对象的方法，持有一个抽象策略引用，通过多态来调用具体策略类对象的方法。
构造具体策略类的对象，客户端把具体策略类对象注入上下文对象并调用上下文对象的方法。
//-------------简要步骤--------------------------end